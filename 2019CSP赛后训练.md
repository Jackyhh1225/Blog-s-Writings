# 2019CSP赛后训练

## 11.21

### T1.[sign](http://192.168.102.138/JudgeOnline/problem.php?cid=1639&pid=0)

​	给一个点(a,b)，问把一个色子从(0,0)沿$l:(0,0)-(a,b)​$，走到(a,b)每一步面朝下的值的和。a,b<=1e18

​	考虑题目其实在问这个问题：

​	记f1表示向上滚一步，f2表示向右滚一步。执行：

```
x=step=0;
while(step<=a+b+1){
	f1;
	x=x+b;
	step=step+1;
	if(step==a+b)break;
	if(x>=a){
		f2;
		x=x-a;
		step=step+1;
	}
}
inv_f1;
```



发现这个相当于：

```
if x<a%b then 
	a/b+1 times f1
	1 time f2
	x=x+b-a%b
end if
if x>=a%b then
	a/b times f2
	1 time f2
	x=x-a%b
end if
```

如果把第一个if里的f操作记为f3，把第二个if里的记为f4，那么

```
while(check()){
	f3;
	x=x+b-a%b;
	if(x>=a%b){
		f4;
		x=x-a%b;
	}
}
相当于
while(check()){
	f4;
	x=x-a%b;
	if(x<b){
		f3;
		x=x+b;
	}
}
```

​	显然x<b，如果把x写成b-x-1，那么这个过程可以改写成最开始的形式，a变成了b，b变成了a%b。递归做就行了，注意边界。

### T2.[easy](http://192.168.102.138/JudgeOnline/problem.php?cid=1639&pid=1)

​	考虑u对v的贡献是$1\over L$，L表示u到v的点数，意思是选v时，u到v中间的所有点都没有被选中过，问题变成求每个长度的路径数。点分治+fft

### T3.[nothard](http://192.168.102.138/JudgeOnline/problem.php?cid=1639&pid=2)

​	询问k=1\~n，点i=1\~k组成的虚树的带权重心。考虑现在已经求出k的重心，现在加入k+1号点，新的重心一定在原来的重心和新加入点的路径上。考虑二分。考虑当前点是u，它有一个相邻的点v，边权为w，v比u更优当且仅当$S_u-S_v>0$，$S_u$表示断开<u,v>后u所在部分关键点个数。树剖上二分可以两个log，在lct上二分可以一个log。

​	算出重心后再用点分治算一下答案就行了。

## 11.22

### T1.[A](http://192.168.102.138/JudgeOnline/problem.php?cid=1640&pid=0)

​	因为是竞赛图，肯定是考虑强连通分量缩点后的链。

​	设$F_i$表示大小为i的竞赛图只有一个强连通分量的个数，$G_i$表示大小为i的竞赛图方案数，可以很方便地算出答案。

​	如果正着算要考虑两个点都在同一个强连通分量的方案数，容斥即可。

​	算F也是容斥$F_i=\Sigma_{j=1}^{i-1}F_jG_{i-j}\binom{i}{j}$。F和G都带标号。

### T2.[B](http://192.168.102.138/JudgeOnline/problem.php?cid=1640&pid=1)

​	直接上构造，因为一共有m=2k条边，一定可以把所有m条边分成k对pair，记为$<e_i,e_j>$，且$e_i,e_j$相邻，所有边只出现过一次。有一个很有用的结论是，从一个奇度数点出发，不停地走pair并删除走过的pair，最后停下的点一定同样是一个奇度数的点。

### T3.[C](http://192.168.102.138/JudgeOnline/problem.php?cid=1640&pid=2)

​	没有顶到结尾的个数显然。接下来考虑顶到了的。

​	一个log做法：先建出后缀树，枚举A+B，考虑A对它的贡献，发现贡献是$cnt_A*(len_{A+B}-L)$，其中L是A对A+B要求长度下界。$L=n-\min\{R_A \setminus R_{A+B} \}+1$。注意这的R集和普通parent树的定义有一些不同。在线段树上实现可撤销的单调栈，可以在一个log的时空复杂度完成。

​	线性做法：同样先建出后缀树，枚举A，考虑A+B对它的贡献，考虑顶到了的定义：对所有以A开头、长度大于等于A+B的后缀一定是以A+B开头的，即在A的子树中len值大于A+B的结点一定在A+B的子树内。

​	根据定义，考虑我们当前枚举到u，那么它对应的A+B一定在它len值最大的子树内，且这些A+B的长度一定大于以儿子为根的子树len值最大值的次大值。

​	又可以发现，所有A对应的A+B一定是从某个叶子开始到当前结点这条链上的最下面几个结点，所以我们可以用一个栈来维护。

## 11.24

### T1.[raining](http://192.168.102.138/JudgeOnline/problem.php?cid=1641&pid=0)

​	一次函数的形式要不是李超树，要不是斜率优化。

​	树上路径问题，考虑用点分治。发现过程是算出根的每个子树内的凸包然后两两合并，复杂度和度数相关，多叉转二叉，然后边分治。可以做到一个log。

### T2.[subtraction](http://192.168.102.138/JudgeOnline/problem.php?cid=1641&pid=1)

​	题解做法：http://192.168.102.138/JudgeOnline/viewsolution.php?cid=1641&pid=1

​	线代做法：https://blog.csdn.net/Vectorxj/article/details/79522322

### T3.[faces](http://192.168.102.138/JudgeOnline/problem.php?cid=1641&pid=2)

​	还不会。

##11.25

### T1.[游戏](http://192.168.102.138/JudgeOnline/problem.php?cid=1642&pid=0)

​	结论：转成坐标，距离轮廓线距离>=2，x+y相同的点状态相同。

### T2.[电影](http://192.168.102.138/JudgeOnline/problem.php?cid=1642&pid=1)

​	形状是一个$\rho$，非环上部分爆搜。换上部分，显然是拆成若干个小环相互配对，一个环上的对应Y值相似，可以一起处理。

### T3.[防御](http://192.168.102.138/JudgeOnline/problem.php?cid=1642&pid=2)

​	主元思想：处理A+B>W的位置，可以维护A-W/2,B-W/2，每次取出大于0的位置，判断是否A+B>W，否则W-=A+B,A=B=0。复杂度lognlogV。

​	考虑如何修改一个区间，可以把区间放进一个分治结构里，区间$[l,r]$放在最小的，区间中点在$[l,r]$里的分治结构的结点上。每个结点的区间看成左右两个部分，按l或r排序后，修改相当于区间加法，找>W的区间按上面的做法。

​	空间复杂度：$O(n\log n\log V)$。空间复杂度：$O(n\log n)$。

​	细节：可能有l相等的区间，把每个l开n个点；l=r要特判。

## 11.27

### T1.[序列](http://192.168.102.138/JudgeOnline/problem.php?cid=1643&pid=0)

​	考虑齐次线性递推，把特征多项式记为A(x)和B(x)，要让F序列相等的条件是它们的特征根相等，即A(x)和B(x)和B(x)%A(x) 的特征根是相等的。把B(x)%A(x)弄出来做待定系数法求出b序列。复杂度n^3。

### T2.[匹配](http://192.168.102.138/JudgeOnline/problem.php?cid=1643&pid=1)

​	dp，发现这dp相当于一个网络流的过程，所以dp值是凸的，那么，合并两个凸函数可以用闵可夫斯基和，线性并归。树剖套分治。复杂度2个log

### T3.[歌曲](http://192.168.102.138/JudgeOnline/problem.php?cid=1643&pid=2)

​	相当于求$\Sigma_i \Sigma_j f[i][j]$。

​	把每个位置i的dp值前缀和当做一个询问，现在相当于有n个询问，我们把它们按二进制分组。

​	枚举K=2^i，处理所有在[K,2K]的询问，把询问变成若干个整段的答案+上一个段的前缀的答案，寻找这个可以使用单调栈加二分。还有可能出现同一区间的询问，发现这样的询问一定是一个整段，可以按拓扑排序继续计算。复杂度2个log。

## 11.28

### T1.[分组](http://192.168.102.138/JudgeOnline/problem.php?cid=1644&pid=0)

​	结论：每一段和的平方的总和最小的方案一定满足。

​	证明：如果两个相邻的段$S_1>S_2$且$\max\{m1,m2\}<S_1-S_2$，把第一段的最右边的数划到第二段去，平方和的总和减小。

​	因为有K段的限制，所以上wqs二分，记录以每个点结尾划分为几段。$O(n\log n)$。

### T2.[行列式](http://192.168.102.138/JudgeOnline/problem.php?cid=1644&pid=1)

​	一个简单无向图的邻接矩阵的行列式相当于把图划分成若干个环或匹配的带权方案数。

​	考虑如果原来的图不连通，且每个连通块是一个大小至少为3的边双连通分量，那么答案是每个连通块的答案的乘积。现在把原图边双缩点后，还有若干树边，而树边只能算进一个匹配中。一个朴素想法是枚举被选近匹配中的树边，把剩下的图按不连通的做法处理。实际上这个步骤可以用树形dp完成。记$F_{i,0/1}$表示处理到i号边双，连到父亲的那条边有没有被选的答案。我们显然不能再像暴力那样枚举被选进匹配中的儿子边，考虑把点双内树边连向儿子的点保留，发现如果把它算进匹配中，相当于连出一个自环。处理是否把连向父亲的树边算进匹配中的转移相似。

​	复杂度：$O(n/k*k^2=nk^2)$。

### T3.[游戏](http://192.168.102.138/JudgeOnline/problem.php?cid=1644&pid=2)

​	构造。考虑相邻两两分组，每个分组询问同一个字符。

​	如果两个询问都对了，显然不能带来任何信息。

​	如果答对了其中一个，把答错的那一位作为信息：下一个连续两个相同的位置是0/1。

​	如果两个都答错了，钦定其中一个作为信息或者把两个都当做信息都可以。

​	证明正确率：如果一组的答案相同，那么期望都答对，消耗一个信息；否则答对其中一个，新增一个信息。期望正确率$3\over4$。因为消耗和新增信息的概率相等，所以期望每次出现相同答案是，都可以答对。

## 11.30

### T1.[A](http://192.168.102.138/JudgeOnline/problem.php?cid=1645&pid=0)

​	又是**的powerful number构造，我又不会。用$\sigma_0$构造。

​	powerful number构造技巧：要求的是F，找一个积性函数G，$G(p)=F(p)$。

### T2.[B](http://192.168.102.138/JudgeOnline/problem.php?cid=1645&pid=1)

​	看起来很难，实际上就是在基环森林上乱搞。

​	假设某一时刻有一个大小为A的等价类，它对答案的贡献是$(1+x)^n-(1+x)^{n-A}$，即全部方案减去不含其中任意一个的方案。上面那个显然是一个减法卷积的形式。考虑求每个A的系数，把等价类的合并按时间建出一颗树，做一遍树形dp。时间$O(n\log n)$。求系数部分，长链剖分是线性的，每次枚举次大值暴力合并是一个log的。

### T3.[C](http://192.168.102.138/JudgeOnline/problem.php?cid=1645&pid=2)

​	模拟费用流，发现增广路是基环树，LCT维护基环森林路径最大值。

## 12.2

### T1.[Mex](http://192.168.102.138/JudgeOnline/problem.php?cid=1646&pid=0)

​	构造FWT

​	$C_0=(A_1+A_2)\circ (B_1+B_2)$

​	$C_1=(A_0+A_2)\circ(B_0+B_2)-A_2\circ B_2$

​	$C_2=A_0\circ B_1+A_1\circ B_0$

​	$C1$的形式很不美观，令$C_3$等于减号后面的，推出：

​	$C_0+C_1+C_2=(A_0+A_1+A_2)\circ(B_0+B_1+B_2)$

​	$C_0=(A_1+A_2)\circ(B_1+B_2)$

​	$C_1+C_3=(A_0+A_2)\circ(B_0+B_2)$

​	$C_3=A_2\circ B_2$

​	把三进制扩成4进制做类FWT变换。

### T2.[随机](http://192.168.102.138/JudgeOnline/problem.php?cid=1646&pid=1)

​	设$p_i$表示第i步走到n的概率，$P(x)$表示概率的生成函数，那么答案就是$P(1)'$。把矩阵的递推式设为$A(x)$BM出来，要把前2n项dp出来，设为$F(x)$。就有$P(x)=P(x)*A(x)+F(x)$，$P(x)=\frac{F(x)}{1-A(x)}$，对等式右边求导算点值。

### T3.[路径](http://192.168.102.138/JudgeOnline/problem.php?cid=1646&pid=2)

​	序列上树或括号序列

## 12.3

### T1.[直线](http://192.168.102.138/JudgeOnline/problem.php?cid=1648&pid=0)

​	对偶后转为数整点

### T2.[节目](http://192.168.102.138/JudgeOnline/problem.php?cid=1648&pid=1)

​	Hall定理模拟费用流。

### T3.[树](http://192.168.102.138/JudgeOnline/problem.php?cid=1648&pid=2)

​	一般的想法是二分求k级祖先或直接k级祖先，而我们要求的是一条路径，所以这样很不优。

​	发现每次询问有两次询问的机会，我们不妨考虑meet-in-the-middle，这启示我们存下每个点的父亲和它到根路径上的中点到根的整条路径。设一个点是**好**的当且仅当它子树内叶子到它的距离的最大值不小于它到根的距离，一个点是**优秀**的，当且仅当它是好的，并且它子树内没有其它好的点。不难证明，我们把所有优秀的点到根的路径都存下来，存储的总长度一定不超过n，于是我们有了以下做法：

​	第一次询问u的父亲和它到根的路径中点子树内优秀的点存的路径的开头。（它到根的路径中点一定是好的）

​	接下来每次输出存的路径，询问路径上的下一个点，询问u的祖先并存进vector里，直到它们相遇。

​	要存下：

​	fa数组，pos数组，路径。一共3n个int。

## 12.5

### T1.[青春野狼不做怀梦少女的梦](http://192.168.102.138/JudgeOnline/problem.php?cid=1649&pid=0)

​	打表发现把每个标记点周围暴力dp后，对角线的函数值相等。

​	会做但不会写。大概就是把每个标记点周围的点都标记起来，从下往上做扫描线，用map存dp值。不会stl的我流下了蒟蒻的泪水T T。

### T2.[青春野狼不做看家妹妹的梦](http://192.168.102.138/JudgeOnline/problem.php?cid=1649&pid=1)

​	原来志愿者招募其实是上下界费用流，网上题解害人不浅啊。

​	因为s是t祖先，所以相当于在序列上。考虑钦定一开始全选B，相当于每条树边有一个上下界，费用是taskR，对于一个询问s,t,vb,vr。在网络流的图上连接e{s,t,sum(taskR)+vr-vb,[0,1]}，e{S,s,0,[1,1]}，e{t,T,0,[1,1]}。那对每个目标，走非树边相当于选R，走树边相当于选B。容易证明每个可行流一定有对应的构造。

### T3.[青春野狼不做初恋少女的梦](http://192.168.102.138/JudgeOnline/problem.php?cid=1649&pid=2)

​	双回文串=数论。

​	问题要求的是长度不找过$n$的双回文串数，考虑求出弱双回文串个数Ans1再减去不是双回文串的弱双回文串个数Ans2。

​	**Lemma1**：若p,q是S的周期，$p+q\leq |S|​$那么$\gcd(p,q)​$也是S的周期。

​	证明：可以发现若p>q，p-q是S的周期，通过辗转减法可以证明。

​	**Lemma2**：若S有大于等于2种弱双回文串划分，则S是一个整周期串。

​	证明：设有两种划分：$p1q1,p2q2$，那么$p1-p2=t$是S的周期，$|S|-t$也是S的周期。通过**Lemma1**可以得到$\gcd(t,|S|)$是S的整周期，所以S是一个整周期串。

​	**Lemma3**：如果弱双回文串$S$的最小整周期是$t$，则它恰好有$|S|/t$种弱双回文串划分。

​	证明：它的每个周期一定是$AB​$的形式，其中A和B是一个回文串，那么它的划分就是每个周期中的A和B中间。特别的$t=|S|​$时，若S是回文串，它的划分是0|S|，否则它一定是AB的形式。

​	通过**Lemma3**，我们用弱双回文串的划分数莫比乌斯反演出最小周期为n的弱双回文串数$F(n)$，设划分数为$G(n)​$，则有：
$$
G(n)=\Sigma_{d|n}F(d)\frac nd\\
F(n)=\Sigma_{d|n}G(d)\mu(\frac nd)\frac nd\\
G(n)=\begin{cases}
n*c^{{n+1}\over2}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ n是奇数\\
{n\over2}*(c^{{n\over2}+1}+c^{n\over2})\ \ n是偶数
\end{cases}
$$
​	G的值：枚举划分点，每个划分点的个数是左边是回文串的数目乘上右边是回文串的数目。

​	$H(n)$是长度为n的弱双回文串个数。$H(n)=\Sigma_{d|n}F(d)$。
$$
\begin{align}
Ans1&=\Sigma_{i=1}^n H(i)\\
&=\Sigma_{i=1}^n(F*1)(i)\\
&=\Sigma_{i=1}^n(G*(\mu \cdot id)*1)(i)\\
&=\Sigma_{i=1}^nG(i)\Sigma_{d=1}^{\lfloor\frac ni\rfloor}K(d)
\end{align}
$$


​	其中$K(n)=(\mu\cdot id)*1$。有$K*id=1$于是可以用杜教筛求K的前缀和。G的前缀和可以看成是等比数列求和在c出的导数。于是可以整数分块求出Ans1。

​	对于Ans2，我们发现它其实是长度不超过n最小整周期为自己的回文串个数。设$L(n)$为长度为n的最小整周期为自己的字符串个数，$P(n)$为长度为n的回文串个数。有：
$$
P(n)=c^{\lceil\frac n2\rceil}\\
P(n)=\Sigma_{d|n}L(d)
$$
​	反演，整数分块后要求莫比乌斯函数的前缀和，同样杜教筛即可。

##12.7

### T1.[房](http://192.168.102.138/JudgeOnline/problem.php?cid=1650&pid=0)

​	结论：每种1的填法所对应的数独填法数目相同。于是暴力搜索填1的方案数乘上k，k由样例得出。

### T2.[励行](http://192.168.102.138/JudgeOnline/problem.php?cid=1650&pid=1)

​	向左，向右走相当于卷积，直接倍增加fft。

### T3.[阿克](http://192.168.102.138/JudgeOnline/problem.php?cid=1650&pid=2)

​	同12.5T2。

## 12.9

### T1.[基础二维数组练习题](http://192.168.102.138/JudgeOnline/problem.php?cid=1651&pid=0)

​	很显然要对每个斜行讨论。

​	对斜行上的每个点求出它能向前和向后能到达的最远的点。如果Ans可行，当且仅当能在某个斜行找到两个距离大于等于Ans的点，满足它们能相互到达，且Ans可行，对x<=Ans也可行。在每个斜行check一下就行了。

​	朴素的check是一次$n^2$的，显然不能接受。用单调栈处理就能每次线性了。

### T2.[基础sam练习题](http://192.168.102.138/JudgeOnline/problem.php?cid=1651&pid=1)

​	容斥后变成每个本质不同的子串的本质不同子串有多少个，即区间本质不同子串个数。

​	把SAM的par树建出来后，每个点对应的区间的右端点相同，左端点是一段区间，考虑扫描线枚举右端点后，在线段树上维护每个左端点的答案，那么每个点的贡献就是区间和。

​	考虑如何求区间本质不同子串个数，同样是容斥，所有子串减去重复算的部分，只保留最后一次扫到的贡献。这相当于把每个子串打上一个las标记，每次扫到它就把它的las的贡献减去，然后把las赋值当前的R，这部分可以用LCT处理。

​	一个SAM上一个点的贡献：对左端点在它的内部，对应一个等差数列，在它的左边，是一个常数。

​	SAM+LCT的套路：维护las。

### T3.[基础fft练习题](http://192.168.102.138/JudgeOnline/problem.php?cid=1651&pid=2)

​	http://192.168.102.138/JudgeOnline/viewsolution.php?cid=1651&pid=2

## 12.10

### T1.[矩阵](http://192.168.102.138/JudgeOnline/problem.php?cid=1652&pid=0)

​	爆搜加剪枝，不会写

### T2.[排列](http://192.168.102.138/JudgeOnline/problem.php?cid=1652&pid=1)

​	qry(a,b,a)=a*(b+1)，(0+1)\*(1+1)\*(2+1)\*...=n! mod n=0，可以问出0的位置。

​	问1的位置，1*a+0=a，每次随机，把不合法的排出，期望问2.5n次。最后用0,1还原。

### T3.[计算](http://192.168.102.138/JudgeOnline/problem.php?cid=1652&pid=2)

​	任务2：a+b=a xor b+(a&b)<<1，把a,b变成a xor b，(a&b)<<1，做64次。

​	任务3：注意只用维护0到64的加一，开8个变量就可以每次加法只用2次操作。

​	任务4：求的是a xor b的最高位与上a的值。用倍增把a xor b最高位以下全部填上1，然后与上它右移一位的值就得到最高位。再把它与上a，倍增把它以上的位全部变成一样在右移63位得到最高位。

​	任务5：过程：枚举x每一位，如果它是1，就把答案乘2加1。要求实现一个if一样的东西，Ans|=((Ans<<1|1)&t)，t是把0/1填满每一位的值，倍增实现。卡次数：倍增次数不用每次都是6，先求出1，每次提取最低位可以直接and 1。

​	任务6：直接$n^2$排序。不用优化。

## 12.12

### T1.[钩子](http://192.168.102.138/JudgeOnline/problem.php?cid=1653&pid=0)

​	现在有一个长度为n的区间，每次会把它从中间断开，分成左右两端区间。把这个建成一个树一样的结构，发现一层的区间取完后才会取下一层的区间，于是考虑一层一层地求答案。

​	先求出每个位置在每一层是能选的概率。现在有两种取法，一种是区间中间2选1，一种是只有一种取法。然后可以算出每一层每一个位置是哪个取法的概率。现在考虑放衣服的顺序。因为有2中取法所以要$dp_{i,j}$表示取到第i个人，有j个人是第一种取法。把它乘上每个位置的概率就是答案。

### T2.[树高](http://192.168.102.138/JudgeOnline/problem.php?cid=1653&pid=1)

​	ett维护连通块。不会。

### T3.[加减](http://192.168.102.138/JudgeOnline/problem.php?cid=1653&pid=2)

​	首先要会合并两个区间的答案。

​	发现dp值对于奇偶是凸的，合并直接闵可夫斯基和。

​	证明：可以建出网络流。