# 一些技巧

[TOC]

## 一些需要注意的点

### 逆向思维

​	例如，求整体的贡献，考虑项的贡献；求至少为1，改为全部，减去为0的；按步骤构造的，考虑最后一步的情景，能不能删掉，改为子问题xsy2559。

### 二分答案

### 差分

### 优化矩阵快速幂

### 条件转化

一些题目可能让你维护一种特殊情况，限制很多不太好维护，这时，我们可以选择容斥或者维护一般的情况，或称维护包含它且可以轻易得到的形式。

例如：[Dates](https://codeforces.com/gym/102268/problem/D)

如果维护每一个位置或已经取了的区间判断很复杂，但如果维护$\forall L,R\ \Sigma_{i=L}^R a_i\geq \Sigma_{i\in S}\left [[l_i,r_i]\subseteq [L,R]\right]$再做转换，就可以做出了。

## 字符串

​	除了从后缀树考虑，还要从DAG考虑。

​	如果有一个S串，很多个询问串T，不妨把询问串T建成AC自动机或广义后缀自动机。

​	一个trick：如果问$S$匹配$T_{1...i},T_{i+K+1...n}$的位置数，可以把询问串建AC自动机，注意S匹配$T_{1...i}$，相当于，S的某个位置在AC自动机上$T_{1...i}​$节点的fail树子树内，对于后缀就把串反过来。最后是一个二维数点，注意去重。LOJ2278

## 动态dp

​	记录一个模板：

```c++
void gao(int x,int y)
{
	val[x]=y;
	update matrix of x
	while(x){
		int tp,l,r;
		Seg::qry f of tp
		if(fa[tp]){
			update fl of fa[tp]
		}
		Seg::qry f of tp
		if(fa[tp]){
			update fl of fa[tp]
			update matrix of fa[tp]
		}
		x=fa[tp]
	}
}
```

需要注意的点：

1.线段树上矩阵乘法的顺序为倒序。

2.如果一个询问要修改好几处的值，最好按dfn序来修改（例子：保卫王国）

## 数论

​	考虑构造powerful numbers，求$\Sigma a_if(i)=\Sigma ai\Sigma_{d|i}g(\frac id)$,其中，$g(i)=\Sigma_{d|i}\mu(i)f(\frac id)$。

## trie处理全部数加一

​	重低位到高位建Trie，从根开始，swap01子树，在它的0子树中重复这一过程。

## 高维前缀和（SOSDP）

O(n)求单项。

## 容斥

### Min-Max

### 二项式反演

### 莫比乌斯反演

### 单位根反演

如果给一段包含'>','<'序列，求一个合法排列数。先看成全部都是<,有一个>系数变成'-1'就行了。

## prufer

一般dp分配位置。

## 线段树二分

只是把删除去掉了，变成log次插入。可以在线。类似二进制分组？

## 区间gcd，带加减修改

把序列差分，变成单点修改

## 树剖

一类序列问题，把它放在树上了，重儿子继承，轻儿子暴力。

## 网络流

​	注意最小割。

​	不是最小割的话，普通网络流只能固定上界，无法固定下界，不妨把下界转成上界。

​	固定上下界可以使用上下界网络流。

## DP

### 数位DP

​	从高到低，从低到高。从低到高的1只是最高位不能为1而已。