# NOI2019赛前集训

UPD：19/6/11 开始了一个大坑：）

## 6.11

### A.标记的连接图

​	~~简单的dp~~，发现所有状态都可以若干层。于是设$f_{i,j}$表示由$i$个点组成的图中，最后一层由$j$个点组成的图的个数，$g_{i,j}$表示.....所有点到跟的距离和。转移就是考虑连接这一层点和上一层点，还有新加的点互相连，最后答案要乘$(n-2)!$。

### B.游戏

​	北京集训时写过，顺便补上题解。先把两个数组排序，然后二分答案。现在图变成了一个二分图，问题变成了二分图博弈问题。现在问题变成$(a_1,b_1)$在不在二分图里面，不好做。二分图最大匹配=点数-二分图最大独立集。要求的就是$(a_1,b_1)$不在某一个最大独立集中。求最大独立集就是相当于找一个划分点，这个点左上方所有的黑点个数+右下方所有白点个数。

### C.脑部进食

​	很容易就可以想到$O((n|s_1||s_2|)^3)$的高消做法。然后发现转移方程的最后一维是分层的，于是可以做到$O((n|s_1|)^3|s_2|)​$。

## 6.12

### A.集合

​	$k=2​$可以$O(n^2)​$做。

​	$k=3，k=4$要推容斥系数。发现$F$的系数要么是0要么是1，所以可以$n^2$预处理每一段区间，它们是由若干个一次函数叠加起来的，然后就可以方便区间求和。预处理完后就可以双指针处理所有函数。我把每种情况都写了一个函数，相当麻烦。

### B.棋盘

​	~~咕咕咕~~

​	搞出来了。结论就是阶梯nim的结论。但是当$k$为偶数，且特殊棋子在第二位的时候要特判。

### C.序列

​	场上怎么就没想出来？？（被SA搞了，以后还是乖乖想SAM吧）

​	后缀树的形态不会变，变的只是某些点的儿子的顺序。发生的变化只有$O(N)$种，发生变化的点的个数是$N​$。于是平衡树维护dfs序。没了

## 6.14

### A.算法

​	每个点对染色方案数的贡献是$n-与它相邻的编号大于它的点数$，考虑维护每个点的贡献。拿set维护每个点的出边，从小到大做启发式合并。

### B.Triangular Lamp

​	atcoder原题，可以把所有点都转移到$x+y=C$的直线上，这个图是和初始图是等价的，然后把一个点转移到每一条直线的图画出来，是一个模2下的杨辉三角，每一行的最后一位和第一位一定是亮的，如果我们能找到这两个点，就一定能找到初始的那个点。

​	我们在研究一下这个杨辉三角的性质，发现它是一个谢尔宾斯基三角形。根据谢尔宾斯基三角形的性质，如果我们找到某个黑点，我们就能每次跳2的k次方找到最左边和最右边。问题转为如何找到一个黑点。

​	为了找到这个黑点，我们需要利用这个式子：
$$
\exists k,\Sigma_{x\ mod\ 3=k}\binom{n}{x}\equiv 1(mod\ 2)
$$
​	然后可以递归做，每次找到mod 2=1的那边。求这个式子显然是一个数位dp。

复杂度：$O(Nlog^2MAX)$。

### C.Hatto Nero

​	二维数据结构sb题。

## 6.15

### A. 智慧树(tree)

​	循环卷积板子题，bluestein做。
$$
\begin{align}
F(\omega^i)&=\Sigma_{j=0}^{n-1}f_j\omega^{ij}\\
&=\Sigma_{j=0}^{n-1}f_j\omega^{\frac{(i+j)^2-i^2-j^2}{2}}
\end{align}
$$

### B.组合数(combination)

​	数位dp加容斥，可以优化到3的n次方。第一次会从小到大地dp。

### C.(string)

​	数据结构题。

​	分三种情况做。

​	第一种是找到每个$a_i​$是最大值的极大区间，做三维数点。

​	第二种是二分询问区间的最小的满足条件的前缀。

​	第二种是二分询问区间的最小的满足条件的后缀。

​	找到一段区间最f值，可以SAM+启发式合并做。

​	时空复杂度都是$O(nlog^2n)$。

​	还有一种每次在线段树插入最大值的做法by yww。

## 6.17

### A.Multiple of Nine

​	题目中的约束相当于让数列中若干个位置的前缀和模9同余。我们把这几个约束的位置提出来，如果这几个位置的值是确定的，那么这个数列的方案是可以算出来的，是$\Pi_ival_i$，其中val是每两个空之间填数的方案数($0\to10^L-1$中模9余k的数的个数)。

​	子集卷积可以完成。$O(8*3^Q)$。

### B.Paths

​	先数出三元环和四元环，然后分类讨论容斥一下。$O(M\sqrt M)​$。

### C.Distinct Boxes

​	http://192.168.102.138/JudgeOnline/viewsolution.php?cid=1603&pid=2

## 6.18

### A. 无向图(graph)

​	分治加按秩合并dsu，两个log正解。

​	lct一个log暴力

### B.线段树(segment)

​	发现操作序列可以预处理，于是可以莫队+点分治。

### C.玩游戏(game)

​	乱搞，维护01区间。

## 6.19

### A.[序列计数](http://192.168.102.138/JudgeOnline/problem.php?cid=1605&pid=0)

​	先算有序的，枚举最小值和公比，公比是$\frac{p}{q}$，是最小值和最大值的比值是平方级的，所以一定可以在根号复杂度下完成。

### B.[苹果](http://192.168.102.138/JudgeOnline/problem.php?cid=1605&pid=1)

​	容斥，dp带容斥系数的。转移可以mlog预处理。

### C.[斐波拉契数串](http://192.168.102.138/JudgeOnline/problem.php?cid=1605&pid=2)

​	我乱搞过的。

## 6.21

### A.[以武装革命颠覆相互强制性价值观之必要性与其实际执行手法](http://192.168.102.138/JudgeOnline/problem.php?cid=1606&pid=0)

​	不会

### B.[革命性宣传计划之始末与阶级性愤怒](http://192.168.102.138/JudgeOnline/problem.php?cid=1606&pid=1)

​	把（当2，把）当-1时，所有前缀和恒不小于0，反过来则所有后缀恒不小于0。预处理所有（往后能匹配到的最远位置，）往前能匹配到的最远位置。这样用线段树加扫描线就可以做完。

​	具体做法就是，对所有（在遇到它的时候在线段树中加入它，然后在pos处把它删掉。对于），相当于对一段区间加上这段区间中还在线段树上的（的个数。学到了

### C.[对于透过大规模仪式进行之恋爱生物间共名的实践与其粉碎方式](http://192.168.102.138/JudgeOnline/problem.php?cid=1606&pid=2)

​	树剖加线段树维护分治ntt。每次修改相当于把$F(x)$变成$F(cx)$。然后递归处理线段树子树的所有点，每次只pushup访问到的点，这样时间复杂度每次修改nlogn的。

## 6.23

### A.[A](http://192.168.102.138/JudgeOnline/problem.php?cid=1607&pid=0)

​	模拟费用流。

### B.[B](http://192.168.102.138/JudgeOnline/problem.php?cid=1607&pid=1)

​	场上就觉得可以在线，可以想hide那题一样$O(1)$合并两个区间的答案，但是我想的是维护c的值，没想出来怎么处理。场后发现这题确实可以在线不过维护的是t，qwq。大概就是每段区间维护lmx，rmx，ans，sum。

### C.[C](http://192.168.102.138/JudgeOnline/problem.php?cid=1607&pid=2)

​	把主串s和所有单词一起放进AC自动机里，按bfs序在AC自动机上计算每个节点的答案。对每个节点我们用一个数据结构维护这个节点表示的字符串中以每个位置为左端点的单词的价值和。遍历到一个节点时，它fail树上的父亲和trie树上的父亲都已经计算过了，用支持快速合并的数据结构维护一下即可。时空复杂度都是一个log。直接复制的。

## 6.24

### A.[购物](http://192.168.102.138/JudgeOnline/problem.php?cid=1608&pid=0)

​	每次单独加入一个新的商店，dp有决策单调性。

​	这样的复杂度是$O(nklogk)$的。考虑优化，发现按取前m位的和排序后最后取m或以上的商店一定是k/m小的商店，于是商店的总个数是$O(klogk)$的。加上决策单调性dp，总复杂度变成了$O(k^2log^k)$。场上以为是一道线性复杂度的送分题，花了相当多的时间在这道题上面。看完题解才发现k<=1000有大用。

​	总结：在发现决策单调性后，如果复杂度还是大于题目要求，可以从减少数据范围的角度来考虑优化。

### B.[简单几何](http://192.168.102.138/JudgeOnline/problem.php?cid=1608&pid=1)

​	数凸四边形。枚举对角线，数在对角线两端的点对个数，在减去凹四边形的数量。做法大概就是极角排序后做个前缀和，还有对角的前缀和。

### C.[子串排列](http://192.168.102.138/JudgeOnline/problem.php?cid=1608&pid=2)

​	虚树+启发式合并+双端队列。

## 6.26

### A.[Cat](http://192.168.102.138/JudgeOnline/problem.php?cid=1609&pid=0)

​	构造题。场上读错题了，漏掉了关键信息导致做不出。。。

​	就是像某一道arc的a题那样，搞成两个山字型的图形拼起来，让要求的矩阵等于两个这样的矩阵减去整个矩阵。

​	特判答案为0,1,2的情况。

​	总结：这题是这场比赛中最简单的一题，但我没能做出来，究其原因，是由于我对自己构造能力不够自信，没有在这道题上投放足够的时间，还漏掉了一个关键的信息。

### B.[Tree](http://192.168.102.138/JudgeOnline/problem.php?cid=1609&pid=1)

​	40pt：连续段计数，记录历史最小值。

​	50pt：序列上的怎么做。相当于枚举左端点，把遇到的点和边加上去，维护历史最小值。

​	100pt：利用树剖，我们可以把树上问题转成序列问题。考虑所有的询问可以被划分成两种情况，两个点的lca是其中一个，和不是其中一个。

​	两个点的lca是其中一个的情况，我们可以直接做，就是每遇到一个连向子树内的点的边，相当于把dfn序上的一段-1，求和就是点到lca这条链上的区间历史最小值次数和。

​	还有就是lca不是任意一个的情况。我们可以把这种情况看成两个情况一的链拼起来，但要注意的是，我们少了若干条跨越lca的边，我们对A树树剖后暴力dfs轻子树加上这样的边就可以。

​	这道题还要求我们用一个数据结构，使其可以满足区间修改操作，查询区间历史最小值出现次数。我们只需要一颗线段树，记录当前最小值、当前最小值出现次数，当前标记，历史最小标记，历史最小标记出现次数即可。感觉是一个套路。

​	总结：这是一道典型的序列问题上树，通过树剖的logn条重链的性质，可以在$log^2$的复杂度内合并两个序列问题从而解决树上的问题。我在场上一直尝试向cf ouuan round 的E题？那样维护连通块，但那种方法会导致出现很多未知的点从而使问题变得很复杂。在发现一条路走不打通，或者说是很难往下走的时候，不妨换一种维护方法，差分之类的，就像这道题，暴力插入边在总复杂度上依然是可行的，不应该拘泥于一种方法中。

### C.[Play](http://192.168.102.138/JudgeOnline/problem.php?cid=1609&pid=2)

​	我对着这道题的题解自闭了一整天，最后还是问了代爷再想了很久才弄懂这道题。这道题还是很有意思的。

​	先把题看成一个网格图，拿走一张牌相当于向下或想做走一步。

​	把两个人的操作合起来看贡献，相当于每次走两步，最后如果还剩一步，可以把那一步枚举走法特判掉。现在n+m是偶数，操作一次相当于走两步。

​	一次操作可以分成两种走法。

​	第一种是连续向左走两步，或者是连续向右走两步。这两个走法是可以一一对应的。那么这样的贡献是$(1-p)+1+p+0$的形式，贡献为2。但这种情况有一种奇异的情况，就是当前出牌处在$y=x$上，且先手为小B，那么这时的贡献为$\frac12+p+1+(1-p)$的形式，多贡献了二分之一，这种情况的出现总次数是：
$$
\Sigma_{i=0}^{n}\binom{2i}{i}\binom{n+m-2i}{i}-2\Sigma_{i=0}^{n-1}\binom{2i}{i}\binom{n+m-2-2i}{n-1-i}\\=\Sigma_{i=0}^{n}\binom{n+m+1}{i}-2\Sigma_{i=0}^{n-1}\binom{n+m-1}{i}
$$
​	第二种是先向下走一步，再向左走一步，或者是先向左走一步，再向下走一步，它们也是一一对应的。这样的贡献是$1+p+0+(1-p)$的形式。类似的如果出牌处在$y=x$上，且先手为小A,那么这时的贡献为$p+(1-p)+1+1​$。贡献多了一，这种情况的出现总次数是：
$$
\Sigma_{i=0}^{n-1}\binom{2i}{i}\binom{n+m-2-2i}{n-1-i}=\Sigma_{i=0}^{n-1}\binom{n+m-1}{i}
$$
总贡献就是$\min(n,m)+奇异情况造成的多出来的贡献$。

​	现在，我们可以$O(n)$的时间内回答每个询问。但发现我们要求的其实是一个组合数前缀和的形式，这可以用莫队解决。总复杂度：$O(n\sqrt m)$。

​	总结：做是做不出的，但题目给到我的一种思考方式：把两种贡献连起来一起看，还有把两个走法的情况一一对应平均两者的贡献从而能更方便地计算。还学到了用莫队维护组合数前缀和的方法。

## 6.28

总结：心态爆炸场。

### A.[Paths in Tree](http://192.168.102.138/JudgeOnline/problem.php?cid=1610&pid=0)

​	傻逼出题人。

​	垃圾输出方案题。

### B.[Quartet Distance](http://192.168.102.138/JudgeOnline/problem.php?cid=1610&pid=1)

​	傻逼出题人x2

​	容斥系数：边-1，点+1

​	考虑对于一对合法的u1,v1,u2,v2。

​	u1,v1的汇合点到u2,v2的汇合点在A上是n，在B上是m

​	那么$cnt_{u1,v1,u2,v2}=n*m+(n+1)(m+1)-n*(m+1)-m*(n+1)=1$。

### C.[Hat With An Integer](http://192.168.102.138/JudgeOnline/problem.php?cid=1610&pid=2)

​	傻逼出题人x3

​	垃圾原题。

## 6.29

### A.[购物](http://192.168.102.138/JudgeOnline/problem.php?cid=1611&pid=0)

​	loj贪玩蓝月的加强版，把查询写成线性的就行了。

### B.[饮料](http://192.168.102.138/JudgeOnline/problem.php?cid=1611&pid=1)

​	可以证明答案的上界是n-1。

​	于是可以暴力枚举答案，每次check相当于做一个dp，设$f_{i,j}$表示当前枚举到第i个瓶子，已经用过的饮料集合为j，且最多只有一种饮料有多的，是否存在这种方案。dp是$O(n^22^n)$的，总复杂是$O(n^32^n)$。

### C.[解密](http://192.168.102.138/JudgeOnline/problem.php?cid=1611&pid=2)

​	于是hint是教你写暴力？

​	考虑$\{c\}$的生成函数$C(x)=\Sigma_{i=0}^{\infty}\Sigma_{j=0}^{n-1}b_ja_j^ix^i=\Sigma_{j=0}^{n-1}\frac {b_j}{1-a_jx}=\frac{\Sigma_{i=0}^{n-1}b_j\Pi_{j!=i}(1-a_jx)}{\Pi_i(1-a_ix)}$。

​	分母可以分治fft求，分子等于分母成$C(x)​$。

​	我们求出了分子，如何求$\{b\}$。

​	对分子求在$x=\frac{1}{a_i}$处的值，就得到了$b_i\Pi_{j!=i}(1-\frac{a_j}{a_i})$。

​	设$f(x)=\Pi_i(x-a_i)​$。求后面的这个乘积就相当于于求$(\frac{f(x)}{x-a_i})(a_i)/a_i^{n-1}​$。

​	根据洛必达法则。当$\lim_{x\to a_i}\frac{f(x)}{x-a_i}=f'(x)$。

​	再做一次多点求值就行了。

## 7.1

### A.[函数](http://192.168.102.138/JudgeOnline/problem.php?cid=1612&pid=0)

​	学习了一个nb trick：powerful numbers。它指的是质因数指数大于等于2的数。这种数在1~N的个数是$O(\sqrt N)$级别的。

​	对于这题，我们想要构造两个积性函数$G,H$，使得$F=G*H$，且$G$只在powerful numbers处非0，H可以很方便地计算前缀和。这样我们就可在$O(\sqrt N*\alpha(h)​$的时间内解决。因为：
$$
\Sigma_{i=1}^NF(i)=\Sigma_{i=1}^N\Sigma_{d|i}G(d)H(\frac id)=\Sigma_{i=0}^{N}G(i)\Sigma_{j=0}^{\lfloor\frac Ni \rfloor}H(j)
$$
​	$G$只在powerful numbers处非0等价于$G$在质数处为0，$p^k=F(p)=H(p)G(1)+H(1)G(p)$，于是$H(p)=p^k$，再推一推$F(p^2)$，就可以知道$H(x)=x^k$，$G(p^e)=p^k-p^{2k}$。于是暴力枚举powerful numbers加拉格朗日插值求自然幂数求和就行了，复杂度：$O(\sqrt N\log_2\sqrt N+K^3\sqrt N)$。

### B.[种树](http://192.168.102.138/JudgeOnline/problem.php?cid=1612&pid=1)

​	如果没有修改，dp很简单。但有修改怎么办。发现这个修改有个性质，你可以把每n个修改看作一轮，那么一轮内，修改到的每一个点，它的祖先一定都被修改过了，且它的子树内没有点被修改过。

​	那就可以dp，设$F_{u,x}$表示u的祖先有多少个1\~u的序列，$G_{u,x}$表示u的子树内有多少个x\~L的序列。

​	修改就是$(Ans-=F_{u,a_u-1}*G_{u,a_u+1})+=F_{u,b_u-1}*G_{u,b_u+1}$。

​	F的求法就是进入这个点的时候更新，出去时还原。G的求法就是记录基于dfn序的前缀和，那么子树的答案就是出来的值减去进去的值。

### C.[字符串](http://192.168.102.138/JudgeOnline/problem.php?cid=1612&pid=2)

​	场上一看这题就是$\log^3$级别的复杂度，于是我想了一个按操作序列分块的$\sqrt n\log_2n$的做法。

​	考完后看题解，发现出题人自称他写了一个两个log做法，是假的，他写成了3个log。这里记录一个我们yy的2个log做法。

​	考虑用旋转treap维护广义sam，每次新加入一个字符串相当将广义Sam的par树上的一个链并加一，预处理可以用lct来处理。treap合并就是把两个节点的广义sam合并。

​	证明为什么这个复杂度是对的。

​	我们把每个节点的pri设为这个节点的子树内字符串总长len次随机的pri取最大值比较，这样旋转的期望就是$\frac {S_u}{S_{fa}+S_u}$。总的期望就是logn个复杂度是$O(n\log_2^2n)$。

​	为了实现这个算法，我们需要写广义sam、lct、和旋转treap。

​	但是实际并不用那么复杂，我们只需要写一个n方暴力就可以通过此题。

## 7.3

### A.[Oriental Puzzle](http://192.168.102.138/JudgeOnline/problem.php?cid=1613&pid=0)

​	先判无解，问题转化为给你一个图，给定一个源点和一个汇点，让你给这个图定向，是它变成一个dag。

​	你可以先把终点提出来，令它的dfn为-1，把这个图的dfs树dfn和low求出来，然后个这个图定向。大概的流程就是，你先钦定1号点为源点，然后对于每一条树边，如果它的儿子可以回到当前源点的上面，这条方向是由源点连出去，否则相当于这个点的子树没有向外流的边，我们就需要让这个点的子树能向外流，等价于将它设为一个新的汇点，然后重复上面的操作。（我有更好的表达方法，但我不打算改了233）

### B.[Inserting Lines](http://192.168.102.138/JudgeOnline/problem.php?cid=1613&pid=1)

​	nbzjt的神奇做法，感觉很有扩展性。

​	插入一行或一列有这样的性质：

​	1.一个插入行的操作相当于重置了这行，即如果我们能找到当前点在某一个插入操作的行或列上面，我们就能直接输出答案。

​	2.只有新的操作能影响就的操作，且影响可以撤销。

​	上面的性质提示我们需要一种算法支持我们可以快速地定位这个点在哪一个插入操作上。我们可以用一颗线段树维护一段区间上操作序列合并后被插入的行列的信息（新插入的会对旧插入的产生影响）。我们可以在线段树上二分一个后缀，然后判断询问点在不在这段区间的插入操作上。然后再递归找到具体的操作，输出答案。

​	插入操作的总复杂度是$O(n\log n)$。

​	因为每次判断询问点在不在井字格上需要二分，所以查询的总复杂度是$O(n\log^2n)$。

### C.[Filling Out](http://192.168.102.138/JudgeOnline/problem.php?cid=1613&pid=2)

​	总可以通过2x3的矩阵将总的矩阵缩成一个10x10的小矩阵（包含那个给定的点）。爆搜即可。

## 7.4

### A.[后缀](http://192.168.102.138/JudgeOnline/problem.php?cid=1614&pid=0)

​	可以dp出这个字符串中开头为0、1、00、01、10、11的个数，找到询问的点在属于那个集合然后递归下去找即可。

### B.[游戏](http://192.168.102.138/JudgeOnline/problem.php?cid=1614&pid=1)

​	交互题。很优秀。

​	首先可以通过加加减减把询问改为询问一个集合内正确的1的个数。

​	暴力的询问次数是$O(n)$的，询问的效率太低，考虑优化询问序列。

​	一个套路方式是如果我们可以通过k次询问确定一个长度为n的字符串，我们可以通过2k次询问确定n+n+k-1的字符串。1\~n设为A，n+1\~2n设为B，2n+1\~2n+k-1设为C。

​	构造方式如下：我们把询问1\~n的询问序列为{P},询问n+1\~2n的询问序列为{Q}。我们先询问出$\{P_i\cup Q_i\}$，再询问出$\{\{A \setminus P_i\}\cup Q_i \cup C_i \}$。然后我们只需要在询问出全集的答案再通过奇偶性就能算出$\{C_i\}$。

​	我们得到全部k次询问的答案后如何还原字符串？

​	首先我们能得到C的答案、询问$\{P\}$和询问$\{Q\}$的答案在递归算出A和B就行了。

### C.[比赛](http://192.168.102.138/JudgeOnline/problem.php?cid=1614&pid=2)

​	语文不好，看不懂题意。

​	发现模型是点i会ban掉$i-a_i \ mod \ n$，且能ban掉的点的编号要小于i。如果一个点已经被ban掉，那么它不会ban掉它能ban掉的点。答案是能ban掉0的点中编号最小的那个点，没有这样的点则答案为0。

​	它构成了一个树的形状，我们需要一个数据结构能维护0的儿子，且能使这个树link-cut。上lct。

​	两个log做法：用set维护每个点的出边。

​	一个log做法：用set维护0的儿子，link、cut一个点相当于reverse链上一段的状态。lct加splay上二分就行了，然而实现很多瓜，要小心（好久没写，陷阱踩了个遍）。

## 7.6

### A.[Jailing Rabbits](http://192.168.102.138/JudgeOnline/problem.php?cid=1615&pid=0)

​	记$f_{i,j,k,l}$为矩阵[i...j,k...l]的答案，$g_{i,j,k,l,o}$表示矩阵...，从o角出去的兔子期望个数。区间dp一下。

### B.[Simple Game](http://192.168.102.138/JudgeOnline/problem.php?cid=1615&pid=1)

​	线段树二分，考虑如果右区间的极差大于X+Y，那么左区间就没有用了。

### C.[Concept of Probability](http://192.168.102.138/JudgeOnline/problem.php?cid=1615&pid=2)

​	一个未被证明的假做法：如果x小于1/2，那么就all in，否则就赌1-x，搜一搜循环节就行了。

## 7.8

### A.[函数](http://192.168.102.138/JudgeOnline/problem.php?cid=1617&pid=0)

​	30pt是状压所有质数，然后把所有数从n到1插入线性基，如果一个数能插进线性基里，说明这个数可以在<=n表示出来，否则不行，那么容斥一下就行了。

### B.[货币](http://192.168.102.138/JudgeOnline/problem.php?cid=1617&pid=1)

​	一个点的值是它的后缀(不包含)的pre的最小值，那就是要在线维护一个单调栈，要做的是合并，分裂这些区间。合并和分裂总数是O(n)的，一次合并、分裂是O(log n)的，加上带维护前后继的启发式合并，这部分是$O(n\log^2 n)$。

### C.[货币](http://192.168.102.138/JudgeOnline/problem.php?cid=1617&pid=1)

​	如果知道根，那么确定字符是线性的，想buildfail那样建就行了，注意要buildfail来check。

​	如何确定根呢？我们把所有fail树和Trie树的重边拿出来，如果这些边组成的图上有度数大于2的点，那么这个点一定为根。否则这个图是一条链，要么是v -b-> rt -aaaaaaaaaaa->u的形式要么就是aaaaaa的形式。那么我们把所有图上的点在Trie树上的兄弟的fail且这个fail在图上的点的fail和它在图上相邻的点拿出来都做一次就行了。

## 7.9

### A.[Cheese](http://192.168.102.138/JudgeOnline/problem.php?cid=1616&pid=0)

​	把一个奶酪看成长为x，宽为y/x，面积为y的矩阵，把这些矩阵按宽排序后，每X/2的面积和一定是递增的，二分就行了，两个log。

### B.[Balanced Rainbow Sequence](http://192.168.102.138/JudgeOnline/problem.php?cid=1616&pid=1)

​	枚举X，表示B的和为X，RG的和分别为-X。接着我们把每个颜色的和调成和X一样，一个很显然的性质是我们肯定是劲量调最靠左的右括号和最靠右的左括号。

​	最后枚举每个前缀和小于0的位置，记前缀和为z，那么为了将它调成>=0的情况，我们至少交换一对左右括号$\lceil \frac{-z+1}{2}\rceil$次。有一个性质就是我们每次交换肯定是交换最左边的右括号和最右边的左括号。那么我们就可以得到若干个限制：记红绿蓝的交换次数分别为r,g,b，那么会得到$r\ge c1,b\ge c2,g\ge c3,r+b\ge c4,g+b\ge c5$。那么令r=c1，g=c3，肯定是最优解。$O(n^2)$。

### C.[Ranges](http://192.168.102.138/JudgeOnline/problem.php?cid=1616&pid=2)

​	线段树分治加扫描线，维护每个点的最优决策区间。